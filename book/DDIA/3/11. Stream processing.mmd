Mind Map generated by NB MindMap plugin   
> __version__=`1.1`,showJumps=`true`
---

# event streams

## unbounded, incrementally processed

## DB world example

### triggers could simulate notification mechanism for consumer

## messaging systems

### main questions

#### What if the producers send messages faster than the consumers can process them?

#####  drop messages

##### buffer messages in a queue

###### what happens as that queue grows

##### apply backpressure \(also known as flowcontrol: blocking the producer from sending more messages\)

#### What if nodes crash or temporarily go offline \- are any messages lost?

##### is durability possible?

### messaging

#### direct

##### ex

###### UDP multicast

###### Brokerless messaging libraries such as ZeroMQ

###### webhook

##### disadvantage

###### consumer/producer is offline, messages might be missed

#### message broker

##### Producers write messages to broker; consumers receive ones by reading them from the broker

##### durability is moved to the broker

##### producers/consumers are generally asynchronous

###### ack only from broker

##### Difference with DB

###### most message brokers automatically delete a message when it is delivered to consumers

###### throughput may degraded if broker needs to buffer messages

###### DB may query data, MB has only subscriptions

###### DB is polling and MB is pushing

##### multiple consumers

###### load balancing

###### fan\-out

#####  preserve the order

###### load balancing \+ redelivery could break it

##### reading is removing from the queue

#### log\-based message broker

##### partitioning across multiple machines

##### fault tolerance by replicating messages

##### no need for every message ack \-\> only consumer's offset

##### reading is alike DB read operation

## keep system in sync
> leftSide=`true`


### dual write

#### concurrency issue

#### fault\-tolerance issue

## change data capture
> leftSide=`true`


### DB changes as a stream

### log compactions remove old/overwritten data

## event sourcing
> leftSide=`true`


### immutable events

### events written to an event log \(append only\)

### mutable state and immutable event log

### command query responsibility segregation

### concurrency

#### simplified because there are immutable events \(not a shared state\)

## processing
> leftSide=`true`


### types

#### write to another system \(DB, cache and etc\)

#### push event to user

#### produce output stream

### materialized view

#### a kind of snapshot or window

### message passing vs RPC

#### actor solves concurrency and distributed execution whereas stream is data management

#### actors communication is ephemeral and one\-to\-one whereas event log is durable and multi\-subscriber

#### actors communicate in acyclic/cyclic ways whereas stream is acyclic pipeline

### timing

#### event time isn't processing time \(for windowing\)

#### when you are ready

##### ignore the straggler event

##### publish a correction

#### event time

##### 1\. when event occured, device clock

##### 2\. when event sent, device clock

##### 3\. when event was received, server clock

##### 4\. substruction from 3 gives the offset

#### windows

##### tumbling

##### hopping

##### sliding

##### session

### fault\-tolerance

#### microbatching

#### checkpoint

## joins

### stream\-table

### stream\-stream

### table\-table
