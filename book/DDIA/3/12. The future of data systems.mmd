Mind Map generated by NB MindMap plugin   
> __version__=`1.1`,showJumps=`true`
---

# Statements

## data integration

### right data in right place

#### there are several solutions: pros/cons/trade\-offs

#### systems circumstances mapped to tools

#### Derived data versus distributed transactions

##### log\-based derived data is promissing approach

#### total ordering

##### single node is sufficient for workload: consensus

#### concurrent events

##### routing all updates for a particular object ID

#### dataflow: inputs/outputs/format/from\-to source

### batch/stream processing

#### consuming inputs, transforming, joining, filtering, aggregating, training models, evaluating, and outputs

### Reprocessing data for application evolution

#### the same data and several schemas

### The lambda architecture

#### incoming data should be recorded by appending immutable events to an always\-growing dataset

####  stream processor consumes the events and quickly produces an approximate update to the view

#### batch processor later consumes the same set of events and produces a corrected version of the derived view

### Unifying batch and stream processing

## Unbundling Databases

### compose data storage technologies

#### create index/create replica

#### The meta\-database of everything

##### Federated databases: unifying reads

##### Unbundled databases: unifying writes

###### main idea is order events log links the apps

### design app around data flow

#### app code as derivation func

#### separate app code and state

#### Interplay between state changes and application code

### observing derived state

#### write path \(keep data up to date\) and read path \(query result again at later time\)

#### shifting boundary between write and read paths

##### no index then no write path and full scan on read path

##### index everything then complex write path and simple read path

##### materialized views/caches also shifts boundaries between them

#### stateful \(offline\-capable\) client

##### do as much as possible offline

##### could be considered as cache of state on the server

##### EventSource API/WebSockets extends write path to the end of read path

#### moving/extending req/resp to pub/sub

#### read/write requests are also stream

#### multi\-partition data processing

## aiming for correctness

### AcID is not enough

#### serializability or atomic commits \(but costs the price\)

#### immutability is very useful \(append\-only data\)

#### exactly\-once using idempotence

### end\-to\-end arguments

#### operation identifier for end\-to\-end flow to skip dups

### Enforcing constraints

#### consensus

#### conflicting writes are routed to the same partition and processed sequentially

#### multi\-partition request

##### add requestId to request and append to the log partitioned based on requestId

##### stream reads request's log and emits instructions

##### further processors consume instructions, dedup by requestId and apply changes

#### timeliness

##### linearizability: system is up\-to\-data

###### inconsistency could be temporary, eventually be resolved 

#### integrity

##### atomicity and durability: absence of corruption \(no data loss, false data or no contradictory\)

#### weaker constraint

##### compensate transaction: applology process 

#### trust and verify

##### auditing \(for an instance read disk blocks\)

##### end\-to\-end check
