Mind Map generated by NB MindMap plugin   
> __version__=`1.1`,showJumps=`true`
---

# spin locks

## types

### local spinning

#### TASLock

#####  repeatedly acquires the lock: while \(state\.getAndSet\(true\)\) \{\}

##### state\.getAndSet\(\) acquires exclusive copy, invalidates other thread's copies

##### bus traffic generated by all threads

#### TTASLock

##### while \(state\.get\(\)\) \{\};<br/>if \(\!state\.getAndSet\(true\)\)<br/>return;\}

##### first state\.get\(\) reads shared copy from the cache

##### bus traffic generated only on release

##### repeatedly reads the lock and then attemps to acquire it

#### back\-off

##### Whenever a thread sees the lock has become free but fails to acquire it, it backs off before retrying

##### drawback

###### it underutilizes the critical section

####### delay on release before another thread attempts to acquire it

###### it can be unfair

####### TASLock and TTASLock may also be unfair

####### thread that just released the lock might never notice that the lock is contended, and so not back off at all

##### pros

###### protects accesses to some shared data structure \- reduces cache misses \- and so reduces bus traffic and avoids the latency of communication

##### cons

###### starving

### queue

#### ALock

##### pros

###### it reduces invalidations to a minimum

###### minimizes the interval between freed up and acquired

###### guarantees no starvation

######  provides first\-come\-first\-served fairness

##### cons

###### it is not space\-efficient

#### CLH

##### pros

###### less space than the ALock

###### does not require knowledge of number of threads

###### it provides first\-come\-first\-served fairness

##### cons

###### it performs poorly on cacheless NUMA architectures

####### If this memory location is remote, then performance suffers

####### On cache\-coherent architectures, however, this approach should work well

#### MCS

##### pros

###### CLH \+ better on NUMA

##### cons

###### releasing a lock requires spinning

###### it requires more reads, writes, and compareAndSet\(\) calls than the CLH

#### TO

##### pros

###### local spinning on a cached location

###### quick detection that the lock is free

###### wait\-free timeout property of the BackoffLock

##### cons

###### the need to allocate a new node per lock access

###### thread spinning on the lock may have to traverse a chain of timed\-out nodes before it can access the critical section

### hierarchical

#### HBO

##### pros

##### cons

###### even worse on NUMA

####### communication costs

####### longer back\-off times for remote threads

#### Composite

##### pros

###### Lock hand\-off is fast

###### When threads back off, they access different locations, reducing contention

##### cons

###### not guaranteed first\-come\-first served access
